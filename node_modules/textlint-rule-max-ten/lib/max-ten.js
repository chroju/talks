// LICENSE : MIT
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

var _textlintRuleHelper = require("textlint-rule-helper");

var _kuromojin = require("kuromojin");

var _sentenceSplitter = require("sentence-splitter");

var _sentenceSplitter2 = _interopRequireDefault(_sentenceSplitter);

var _structuredSource = require("structured-source");

var _structuredSource2 = _interopRequireDefault(_structuredSource);

var defaultOptions = {
    max: 3, // 1文に利用できる最大の、の数
    strict: false // 例外ルールを適応するかどうか
};

function isSandwichedMeishi(_ref2) {
    var before = _ref2.before;
    var token = _ref2.token;
    var after = _ref2.after;

    if (before === undefined || after === undefined || token === undefined) {
        return false;
    }
    return before.pos === "名詞" && after.pos === "名詞";
}
/**
 * add two positions.
 * note: line starts with 1, column starts with 0.
 * @param {Position} base
 * @param {Position} relative
 * @return {Position}
 */
function addPositions(base, relative) {
    return {
        line: base.line + relative.line - 1, // line 1 + line 1 should be line 1
        column: relative.line == 1 ? base.column + relative.column // when the same line
        : relative.column // when another line
    };
}
/**
 * @param {RuleContext} context
 * @param {object} options
 */

exports["default"] = function (context) {
    var options = arguments.length <= 1 || arguments[1] === undefined ? {} : arguments[1];

    var maxLen = options.max || defaultOptions.max;
    var isStrict = options.strict || defaultOptions.strict;
    var helper = new _textlintRuleHelper.RuleHelper(context);
    var Syntax = context.Syntax;
    var RuleError = context.RuleError;
    var report = context.report;
    var getSource = context.getSource;

    return _defineProperty({}, Syntax.Paragraph, function (node) {
        if (helper.isChildNode(node, [Syntax.BlockQuote])) {
            return;
        }
        var sentences = (0, _sentenceSplitter2["default"])(getSource(node), {
            charRegExp: /[。\?\!？！]/,
            newLineCharacters: "\n\n"
        });
        /*
        <p>
        <str><code><img><str>
        <str>
        </p>
         */
        /*
        # workflow
        1. split text to sentences
        2. sentence to tokens
        3. check tokens
         */
        return (0, _kuromojin.getTokenizer)().then(function (tokenizer) {
            sentences.forEach(function (sentence) {
                var text = sentence.value;
                var source = new _structuredSource2["default"](text);
                var currentTenCount = 0;
                var tokens = tokenizer.tokenizeForSentence(text);
                var lastToken = null;
                tokens.forEach(function (token, index) {
                    var surface = token.surface_form;
                    if (surface === "、") {
                        // 名詞に過去まわれている場合は例外とする
                        var isSandwiched = isSandwichedMeishi({
                            before: tokens[index - 1],
                            token: token,
                            after: tokens[index + 1]
                        });
                        // strictなら例外を例外としない
                        if (!isStrict && isSandwiched) {
                            return;
                        }
                        currentTenCount++;
                        lastToken = token;
                    }
                    if (surface === "。") {
                        // reset
                        currentTenCount = 0;
                    }
                    // report
                    if (currentTenCount >= maxLen) {
                        var positionInSentence = source.indexToPosition(lastToken.word_position - 1);
                        var positionInNode = addPositions(sentence.loc.start, positionInSentence);
                        var ruleError = new context.RuleError("一つの文で\"、\"を" + maxLen + "つ以上使用しています", {
                            line: positionInNode.line - 1,
                            column: positionInNode.column
                        });
                        report(node, ruleError);
                        currentTenCount = 0;
                    }
                });
            });
        });
    });
};

module.exports = exports["default"];
//# sourceMappingURL=max-ten.js.map