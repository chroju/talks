{"version":3,"sources":["../src/sentence-length.js"],"names":[],"mappings":";AACA;;;;;;kBAUe,UAAU,OAAV,EAAiC;AAAA,QAAd,OAAc,yDAAJ,EAAI;;AAC5C,QAAM,YAAY,QAAQ,GAAR,IAAe,eAAe,GAAhD;AACA,QAAM,SAAS,mCAAe,OAAf,CAAf;AAF4C,QAGvC,MAHuC,GAGV,OAHU,CAGvC,MAHuC;AAAA,QAG/B,SAH+B,GAGV,OAHU,CAG/B,SAH+B;AAAA,QAGpB,MAHoB,GAGV,OAHU,CAGpB,MAHoB;;;AAK5C,+BACK,OAAO,SADZ,YACuB,IADvB,EAC4B;AACpB,YAAI,OAAO,WAAP,CAAmB,IAAnB,EAAyB,CAAC,OAAO,UAAR,CAAzB,CAAJ,EAAmD;AAC/C;AACH;AACD,YAAI,OAAO,iCAAS,IAAT,CAAX;;AAEA,YAAI,YAAY,6BAAM,IAAN,EAAY;AACxB,+BAAmB;AADK,SAAZ,CAAhB;AAGA,kBAAU,OAAV,CAAkB,oBAAY;;AAE1B,gBAAI,eAAe,SAAS,KAA5B;;AAEA,gBAAI,aAAa,MAAb,GAAsB,SAA1B,EAAqC;AACjC,oBAAI,cAAc,KAAK,GAAL,CAAS,KAAT,CAAe,IAAjC;AACA,oBAAM,YAAY,mBAAmB,YAAnB,IACZ,SAAS,GAAT,CAAa,KAAb,CAAmB,IAAnB,GAA0B,C;AADd,kBAEZ,SAAS,GAAT,CAAa,KAAb,CAAmB,IAAnB,GAA0B,CAFhC,C;AAGA,oBAAI,cAAc,KAAK,GAAL,CAAS,SAAT,EAAoB,CAApB,CAAlB;AACA,oBAAI,eAAe,SAAS,KAAT,CAAe,CAAf,CAAnB;AACA,uBAAO,IAAP,EAAa,IAAI,SAAJ,YAAsB,cAAc,WAApC,6CAAsF,SAAtF,QAAoG;AAC7G,2BAAO;AADsG,iBAApG,CAAb;AAGH;AACJ,SAfD;AAgBH,KA1BL;AA4BH,C;;AA1CD;;AACA;;;;AACA;;;;;;AACA,IAAM,qBAAqB,SAArB,kBAAqB,CAAC,IAAD,EAAU;AACjC,WAAO,QAAQ,KAAK,MAAL,CAAY,CAAZ,MAAmB,IAAlC;AACH,CAFD;AAGA,IAAM,iBAAiB;AACnB,SAAK;AADc,CAAvB","file":"sentence-length.js","sourcesContent":["// LICENSE : MIT\n\"use strict\";\nimport {split} from \"sentence-splitter\";\nimport toString from 'mdast-util-to-string';\nimport {RuleHelper} from \"textlint-rule-helper\";\nconst isStartWithNewLine = (text) => {\n    return text && text.charAt(0) === \"\\n\";\n};\nconst defaultOptions = {\n    max: 100\n};\nexport default function (context, options = {}) {\n    const maxLength = options.max || defaultOptions.max;\n    const helper = new RuleHelper(context);\n    let {Syntax, RuleError, report} = context;\n    // toPlainText\n    return {\n        [Syntax.Paragraph](node){\n            if (helper.isChildNode(node, [Syntax.BlockQuote])) {\n                return;\n            }\n            let text = toString(node);\n            // empty break line == split sentence\n            let sentences = split(text, {\n                newLineCharacters: \"\\n\\n\"\n            });\n            sentences.forEach(sentence => {\n                // TODO: should trim()?\n                let sentenceText = sentence.value;\n                // bigger than\n                if (sentenceText.length > maxLength) {\n                    let currentLine = node.loc.start.line;\n                    const addedLine = isStartWithNewLine(sentenceText)\n                        ? sentence.loc.start.line + 1// \\n string\n                        : sentence.loc.start.line - 1; // string\n                    let paddingLine = Math.max(addedLine, 0);\n                    let paddingIndex = sentence.range[0];\n                    report(node, new RuleError(`Line ${currentLine + paddingLine} exceeds the maximum line length of ${maxLength}.`, {\n                        index: paddingIndex\n                    }));\n                }\n            });\n        }\n    }\n}"]}