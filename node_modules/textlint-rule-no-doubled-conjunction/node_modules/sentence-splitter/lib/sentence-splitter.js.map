{"version":3,"sources":["../src/sentence-splitter.js"],"names":[],"mappings":"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","file":"sentence-splitter.js","sourcesContent":["// LICENSE : MIT\n\"use strict\";\nimport StructureSource from \"structured-source\";\nconst defaultOptions = {\n    charRegExp: /[\\.。\\?\\!？！]/,\n    newLineCharacters: \"\\n\"\n};\nexport const Syntax = {\n    \"WhiteSpace\": \"WhiteSpace\",\n    \"Sentence\": \"Sentence\"\n};\n/**\n * @param {string} text\n * @param {{\n *      charRegExp: ?Object,\n *      newLineCharacters: ?String\n *  }} options\n * @returns {Array}\n */\nexport function split(text, options = {}) {\n    const matchChar = options.charRegExp || defaultOptions.charRegExp;\n    const newLineCharacters = options.newLineCharacters || defaultOptions.newLineCharacters;\n    const src = new StructureSource(text);\n    let createNode = (type, start, end)=> {\n        let range = [start, end];\n        let location = src.rangeToLocation(range);\n        let slicedText = text.slice(start, end);\n        let node;\n        if (type === Syntax.WhiteSpace) {\n            node = createWhiteSpaceNode(slicedText, location, range);\n        } else if (type === Syntax.Sentence) {\n            node = createSentenceNode(slicedText, location, range);\n        }\n        return node;\n    };\n    let results = [];\n    let startPoint = 0;\n    let currentIndex = 0;\n    let isSplitPoint = false;\n    const newLineCharactersLength = newLineCharacters.length;\n    for (; currentIndex < text.length; currentIndex++) {\n        let char = text[currentIndex];\n        let whiteTarget = text.slice(currentIndex, currentIndex + newLineCharactersLength);\n        if (whiteTarget === newLineCharacters) {\n            // (string)\\n\n            if (startPoint !== currentIndex) {\n                results.push(createNode(Syntax.Sentence, startPoint, currentIndex));\n            }\n            for (let i = 0; i < newLineCharactersLength; i++) {\n                // string(\\n)\n                let startIndex = currentIndex + i;\n                results.push(createNode(Syntax.WhiteSpace, startIndex, startIndex + 1));\n            }\n            // string\\n|\n            startPoint = currentIndex + newLineCharactersLength;\n            isSplitPoint = false;\n        } else if (matchChar.test(char)) {\n            isSplitPoint = true;\n        } else {\n            // why `else`\n            // it for support 。。。 pattern\n            if (isSplitPoint) {\n                results.push(createNode(Syntax.Sentence, startPoint, currentIndex));\n                // reset stat\n                startPoint = currentIndex;\n                isSplitPoint = false;\n            }\n        }\n    }\n\n    if (startPoint !== currentIndex) {\n        results.push(createNode(Syntax.Sentence, startPoint, currentIndex));\n    }\n    return results;\n}\n/**\n * @param {string} text\n * @param {Object} loc\n * @param {number[]} range\n * @returns {{type: string, raw: string, value: string, loc: Object, range: number[]}}\n */\nexport function createWhiteSpaceNode(text, loc, range) {\n    return {\n        type: \"WhiteSpace\",\n        raw: text,\n        value: text,\n        loc: loc,\n        range: range\n    }\n}\n/**\n * @param {string} text\n * @param {Object} loc\n * @param {number[]} range\n * @returns {{type: string, raw: string, value: string, loc: Object, range: number[]}}\n */\nexport function createSentenceNode(text, loc, range) {\n    return {\n        type: \"Sentence\",\n        raw: text,\n        value: text,\n        loc: loc,\n        range: range\n    }\n}"]}